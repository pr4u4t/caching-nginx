user                	root;
worker_processes    	auto;
error_log           	logs/error.log warn;
worker_rlimit_nofile 	40960;

events {
    worker_connections  10240;
    use epoll;
    multi_accept on;
}

http {
    aio on;
    lua_need_request_body on;
    
    include       mime.types;
    include	  log.conf;
    include       gzip.conf;
    include       http.conf;
    
    resolver      127.0.0.1;
    include       cache.conf;
    
	init_by_lua_block {
        	require "utils"
        	require "ini"
        	local settings = require "settings"
        	settings:load("/opt/openresty/nginx/conf/waf.ini")
        	local platform = require "platform"
        	require "ipmatcher"
        	--require "endpoint"
        	require "httpd"
        	require "resolver"
        	require "dnsd"
        	require "resty.limit.conn"
        	require "resty.limit.req"
        	require "resty.limit.traffic"
        	require "resty.redis"
        
        	if settings.platform.flush_on_HUP == true then
            		platform.shared.sessions:flush_all()
            		platform.shared.accessapi:flush_all()
            		platform.shared.vhosts:flush_all()
            		platform.shared.certs:flush_all()
            		platform.log.print(platform.log.ERR,"Cache flushed")
        	end
	}

	init_worker_by_lua_block {
		local proc = require "ngx.process"
		ngx.log(ngx.ERR,proc.type())
	}

	upstream dynamic {
        zone dynamic 256k;
        server 0.0.0.1:1234;   # just an invalid address as a place holder

        balancer_by_lua_block {
            require "httpd":serveBackend()
        }
    }
	
    # HTTP Server
    server {
	access_log              logs/http_access.log;
        set $idxFileNames 	'';
        
        set_by_lua_block $idxFileNames          { return require "settings".platform.index_files   }
        
        listen                    80 so_keepalive=30s:2s:8 reuseport;
        listen                    [::]:80 so_keepalive=30s:2s:8 reuseport;

        server_name               _;
        index                     $idxFileNames;
        lua_check_client_abort    on;

	include proxy_internal.conf;
        #include set_ip.conf;
        #include lua_stat.conf;
        #include lua_nginx.conf;
   }


    # HTTPS server
    server {
	access_log              logs/https_access.log;
        set $idxFileNames       '';
        
        set_by_lua_block $idxFileNames          { return require "settings".platform.index_files           }
        
        listen                    443 ssl http2 so_keepalive=30s:2s:8 reuseport;
        listen                    [::]:443 ssl http2 so_keepalive=30s:2s:8 reuseport;
            
        server_name               _;
        index                     $idxFileNames;
        lua_check_client_abort    on;

        include ssl.conf;

        ssl_certificate_by_lua_block {
        	require "httpd":load_certs()
        }

	include proxy_internal.conf;

        #include set_ip.conf;
        #include lua_nginx.conf;
   }

   #internal server
   server {
	set $reqUrl '';
	server_name _;
	listen 127.0.0.1:8081 reuseport;
	include lua_nginx.conf;
   }
}

stream {
    lua_package_path    ";;/usr/lib/luarocks/rocks-5.1/?.lua;";
    lua_package_cpath   ";;/usr/lib/lua/5.1/?.so";
    
    init_by_lua_block {
        require "utils"
        require "ini"
        require "settings":load("/opt/openresty/nginx/conf/waf.ini")
        require "platform"
        require "streamd"
    }
    
    upstream ns_backend {
        server 0.0.0.1:53;   # just an invalid address as a place holder

        balancer_by_lua_block {
            require "streamd":serveRequest()
        }
    }
    
    server {
        listen 53   udp;
        proxy_pass  ns_backend;
        proxy_responses 1;
    }
    
    server {
        listen 53;
        proxy_pass  ns_backend;
    }
    
    server {
        listen 8053;
        
        content_by_lua_block {
            require "dnsd":serveRequest()
        }
    }
}
