set $vHostDocRoot       '';
set $vHost              $http_host;
set $reqFile            $uri;
set $reqArg             $args; #this could be probably replaced
set $srvRoot            '';
set $fastcgiIndex       '';
set $backend_proto      '';
set $pvHost             '';
set $proxyCache         'off';
set $fcgiCache          'off';
set $scgiCache          'off';
set $uwsgiCache         'off';
set $dohCache           'off';

set_by_lua_block $srvRoot        { return require "settings".directory.localPrefix                 }
set_by_lua_block $proxyCache     { return require "settings".cache.proxyCache                      }
set_by_lua_block $fcgiCache      { return require "settings".cache.fcgiCache                       }
set_by_lua_block $scgiCache      { return require "settings".cache.scgiCache                       }
set_by_lua_block $uwsgiCache     { return require "settings".cache.uwsgiCache                      }
set_by_lua_block $dohCache       { return require "settings".cache.dohCache                        }

access_by_lua_block{
    require "httpd":sieve()
}

log_by_lua_block {
    if require "settings".access_control.cf_track then
        require "httpd":countRatelimit()
    end
}

location / {
    root                $srvRoot;
    default_type        'text/html';
    keepalive_timeout   300;
    keepalive_requests  100000;
    
    rewrite_by_lua_block {
        require "httpd":validate_by_waf_request()
    }                             
                                
    header_filter_by_lua_block {
        require "httpd":validate_by_waf_response()
    }
    
    content_by_lua_block {
		require "httpd":serveRequest()
    }
    
    log_by_lua_block {
        require "httpd":log_by_waf()
    }
}

location @badip {
    internal;
    root html/error;
    rewrite ^ badip.html break;
}

location @proxy {
    internal;
    proxy_cache                     $proxyCache;
    proxy_cache_valid               200  12h;
    proxy_cache_revalidate          on;
    proxy_cache_use_stale           error timeout invalid_header updating http_500 http_502 http_503 http_504;
    proxy_buffering                 on;
    proxy_cache_background_update   on;
    proxy_cache_lock                on; #this may be the subject of real life test
    proxy_cache_key                 $host$uri$is_args$args$slice_range;
    proxy_intercept_errors          on;
    slice 1m;
    
    set_by_lua_block $backend_proto { return require "httpd":fetchInfo()["protocol"] }
    set_by_lua_block $pvHost        { return require "httpd":fetchInfo()["hostHeader"] or hplatform.var.vHost }
    
    
    proxy_connect_timeout           2s; #proxy timeouts are aggressive to make a quick switch to next
    proxy_send_timeout              2s; #backend in case of down 
    proxy_read_timeout              2s;
    #resolver                       127.0.0.1;
    proxy_pass                      $backend_proto://dynamic$reqFile;
    proxy_set_header                Host $pvHost;
    proxy_set_header                Connection "";
    proxy_set_header                Range $slice_range;
    proxy_http_version              1.1;
                                
    rewrite_by_lua_block {
	ngx.log(ngx.ERR,'FILE: ',ngx.var.reqFile)
	ngx.log(ngx.ERR,'HOST: ',ngx.var.pvHost)
        require "httpd":validate_by_waf_request()
    }                             
                                
    header_filter_by_lua_block {
        if not require "settings".platform.proxy then
            return platform.exec("/error/403.html")
        end
    
        if require "settings".proxy.location_rewrite then
            require "httpd":proxyRewrite()
        end
        
        require "httpd":validate_by_waf_response()
    }
    
    body_filter_by_lua_block {
        require "httpd":validate_by_waf_body()
    }
    
    log_by_lua_block {
        require "httpd":log_by_waf()
    }
}

location @static {
    internal;
    root        $srvRoot;
    try_files   $reqUrl $reqUrl/index.html $reqUrl/index.htm =404;
}

location @fcgi {
    fastcgi_cache $fcgiCache;
    fastcgi_cache_valid 200 301 302 1d;
    fastcgi_cache_background_update on;
    fastcgi_cache_use_stale error timeout invalid_header updating http_500 http_503;
    fastcgi_cache_lock on;
    fastcgi_request_buffering  on;
    fastcgi_cache_key "$scheme$request_method$host$request_uri";
    
    internal;
    root                            $srvRoot$vHostDocRoot;
    default_type                    text/html;

    fastcgi_buffers 16              16k;
    fastcgi_buffer_size             32k;

    fastcgi_pass                    dynamic;
    fastcgi_index                   $fastcgiIndex;
    include                         fastcgi_params;
    fastcgi_param   SCRIPT_FILENAME $srvRoot$vHostDocRoot$reqFile;
    fastcgi_param	PATH_INFO	    $reqFile;
    fastcgi_param   QUERY_STRING    $reqArg;
                                        #don't you dare to change this 
    fastcgi_param   SCRIPT_NAME     ""; #NO MATTER what is placed here, one of the CMS stops working
                                        #only solution is to keep this empty
    fastcgi_param 	HTTP_PROXY      "";
    fastcgi_intercept_errors        on;
    fastcgi_connect_timeout         2s;
    fastcgi_read_timeout            900s;
    fastcgi_send_timeout            900s;
    fastcgi_socket_keepalive        on;
	
    rewrite_by_lua_block {
        local platform  = require "platform"
        if not require "settings".platform.fcgi then
            return platform.exec("/error/403.html")
        end
        
        require "httpd":validate_by_waf_request()
    }
   
    header_filter_by_lua_block {
        if require "settings".proxy.location_rewrite then
            require "httpd":proxyRewrite()
        end
        
        require "httpd":validate_by_waf_response()
    }
    
    body_filter_by_lua_block {
        require "httpd":validate_by_waf_body()
    }
    
    log_by_lua_block {
        require "httpd":log_by_waf()
    }
}

location @uwsgi {
    uwsgi_cache $uwsgiCache;
    uwsgi_cache_valid 200 301 302 1d;
    uwsgi_cache_background_update on;
    uwsgi_cache_use_stale error timeout invalid_header updating http_500 http_503;
    uwsgi_cache_lock on;
    uwsgi_request_buffering  on;
    uwsgi_cache_key "$scheme$request_method$host$request_uri";
    uwsgi_intercept_errors        on;
    
    internal;
    root                            $srvRoot;
    default_type                    text/html;
    
    rewrite_by_lua_block {
        local platform  = require "platform"
        if not require "settings".platform.uwsgi then
            return platform.exec("/error/403.html")
        end
        
        require "httpd":validate_by_waf_response()
    }
   
    header_filter_by_lua_block {
        require "httpd":validate_by_waf_response()
    }
    
    body_filter_by_lua_block {
        require "httpd":validate_by_waf_body()
    }
    
    log_by_lua_block {
        require "httpd":log_by_waf()
    }
}

location @scgi {
    scgi_cache $scgiCache;
    scgi_cache_valid 200 301 302 1d;
    scgi_cache_background_update on;
    scgi_cache_use_stale error timeout invalid_header updating http_500 http_503;
    scgi_cache_lock on;
    scgi_request_buffering  on;
    scgi_cache_key "$scheme$request_method$host$request_uri";
    scgi_intercept_errors        on;
    
    internal;
    root                            $srvRoot;
    default_type                    text/html;
    
    rewrite_by_lua_block {
        local platform  = require "platform"
        if not require "settings".platform.scgi then
            return platform.exec("/error/403.html")
        end
        
        require "httpd":validate_by_waf_response()
    }
   
    header_filter_by_lua_block {
        require "httpd":validate_by_waf_response()
    }
    
    body_filter_by_lua_block {
        require "httpd":validate_by_waf_body()
    }
    
    log_by_lua_block {
        require "httpd":log_by_waf()
    }
}

location @dir {
    internal;
    root        $reqFile;
    index       index.html;
    autoindex   on;
}

error_page 500 502 503 504          /error/50x.html;
error_page 404                      /error/404.html;
error_page 403                      /error/403.html;

location ~ /error/.+ {
	root html;
	
#   rewrite_by_lua_block {
#        ngx.log(ngx.ERR,"SEVERITY: ",ngx.var.highest_severity)
#   }
}

location ~ /dns-query {
#    internal;
    proxy_http_version              1.1;
    proxy_set_header                Connection "";
    proxy_cache                     $dohCache;
    proxy_cache_key                 $scheme$proxy_host$uri$is_args$args$request_body;
    proxy_pass                      http://127.0.0.1:8053;
    proxy_cache_background_update   on;
    proxy_cache_lock                on; #this may be the subject of real life test
    proxy_cache_methods             GET POST HEAD;
    proxy_connect_timeout           2s; #proxy timeouts are aggressive to make a quick switch to next
    proxy_send_timeout              2s; #backend in case of down 
    proxy_read_timeout              2s;
    proxy_intercept_errors          on;
    proxy_cache_revalidate          on;
    proxy_cache_use_stale           error timeout invalid_header updating http_500 http_502 http_503 http_504;
    proxy_buffering                 on;
    proxy_cache_valid               200  1h;
}

location /status/site/alive {
    proxy_pass http://35.190.93.238:80/he/alive;
    proxy_cache off;
    proxy_set_header Host israel.tv;
}

location /status/api/alive {
    proxy_pass http://35.204.198.133:80/auth/api/alive.php;
    proxy_cache off;
    proxy_set_header Host s1.israel.tv;	
}

location /status/httpd {
    stub_status on;
    access_log  off;
}
